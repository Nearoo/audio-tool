{"version":3,"sources":["views/presets.js","views/presetBrowser.js","graph/audio.js","graph/bang.js","graph/flow.js","scheduler/time.js","scheduler/scheduler.js","graph/edges.js","views/edgeTypes.js","common/hooks.js","graph/handles.js","graph/nodeContainer.js","gui/gui.js","scheduler/sequencers.js","nodes/sequencer.js","views/nodeTypes.js","nodes/urBang.js","nodes/sampler.js","nodes/audioOut.js","views/graphView.js","views/defaultGraph.js","views/storageController.js","App.js","reportWebVitals.js","index.js"],"names":["presets","sampler","forEach","presetName","push","name","data","loop","path","PresetBrowser","props","style","margin","Object","keys","map","typeName","Panel","header","size","bordered","dataSource","renderItem","item","Item","draggable","onDragStart","ev","dataTransfer","setData","JSON","stringify","type","effectAllowed","globalAudioGraph","registerNode","node","nodeIdentifier","nodeMap","deregisterNode","id","connectNodes","id1","id2","connect","disconnectNodes","disconnect","isAudioNode","areConnected","is","this","globalBangGraph","registerOutputNode","triggererMap","Set","getTriggerCallbackForOutputNode","time","triggeree","triggereeMap","deregisterOutputNode","inputNode","registerInputNode","callback","deregisterInputNode","add","delete","isBangNode","FlowGraphContext","React","createContext","FlowGraphProvider","localStorageKey","createUniqueId","uuidv4","pushElement","element","setState","state","elements","pullElement","pullElementById","_","reject","pullElementByPredicate","pred","filter","el","replaceElementById","element_","getElementById","find","createNode","position","createEdge","sourceNode","sourceHandle","targetNode","targetHandle","source","target","setNodeData","getNodeData","deleteEdgesConnectedToHandle","handleId","render","Provider","value","children","setElements","reactFlowInstance","setReactFlowInstance","deleteElement","Component","TimeResolution","bpm","ppb","pulsePerSecond","secondPerPulse","Time","pulse","res","toSeconds","toPulse","subtract","multiply","factor","isBefore","isAfter","isOnOrBefore","isOnOrAfter","isNever","Number","POSITIVE_INFINITY","fromSeconds","seconds","remainder","Math","floor","fromPulse","fromBarNotation","notation","split","v","i","pulserPerPart","SchedulerTime","scheduler","getResolution","schedule","scheduleLater","scheduleDraw","mod","toString","justBefore","justAfter","fromTime","globalScheduler","lookAhead","debug","msg","console","now","isRunning","doStop","resolution","getNewEventId","lastScheduledEventId","_rescheduleDispatch","clearTimeout","dispatchTimeoutID","setTimeout","dispatch","clear","eventQueue","isEmpty","poll","stop","emit","start","peek","callbackRegister","dataRegister","_cleanUp","t","assert","unschedule","eventId","warn","removeOne","replaceScheduledCallback","replaceEventData","s","Tone","FastPriorityQueue","ev1","ev2","p","b","barNot","Emitter","never","useOnGlobalSchedulerStart","useEffect","on","useOnGlobalSchedulerStop","CustomPath","sourceX","sourceY","targetX","targetY","sourcePosition","targetPosition","d","getBezierPath","edgeTypes","audio","selected","sourceHandleId","targetHandleId","strokeWidth","fill","stroke","bang","useState","flash","setFlash","doFlash","edgeIdentifier","color","useEffectWithPrevious","currentValue","firstValue","previousValue","ref","useRef","current","usePrevious","BaseHandle","width","height","zIndex","posToBorderRadius","top","left","right","bottom","SourceBangHandle","isBanging","setBanging","useCallback","bangReciverNodeId","useMemo","borderRadius","backgroundColor","border","TargetBangHandle","handleKinds","Handle","kind","parentId","updateNodeInternals","useUpdateNodeInternals","SelectedHandle","globalAllNodes","insideNodeContainer","Node","onHandleRemove","pushHandle","handle","handles","pullHandle","context","toAudioNodeIdentifier","handleName","toBangInputNodeIdentifier","toBangOutputNodeIdentifier","addAudioInputHandle","audioNode","removeAudioInputHandle","addAudioOutputHandle","removeAudioOutputHandle","addBangInputHandle","removeBangInputHandle","addBangOutputHandle","removeBangOutputHandle","componentDidMount","componentWillUnmount","getAsReactFlowElement","getData","title","useTitle","useData","initialData","dataId","doClear","r","setR","dataOrF","newData","Function","useAudioInputHandle","useAudioOutputHandle","useBangInputHandle","useBangOutputHandle","useBangOutputHandles","numHandles","handleNamePrefix","handleNames","Array","nodeIdentifiers","callbacks","identifier","previousNodeIdentifiers","newNodeIdentifiers","slice","length","discardingNodeIdentifiers","outerStyle","minWidth","minHeight","fontSize","boxShadow","offsets","SaveOutlined","getOffsetForHandleOfSide","side","offset","key","padding","paddingLeft","cursor","className","contextType","NumberInputer","min","precision","step","Transport","loopInterval","getUniqueEventId","eventIdCounter","tpid","isScheduled","tpEvents","tptime","gltime","glStartTime","glid","tp2glEvents","nextControlEventId","interval","entries","addEvent","getTpNow","removeEvent","removeAllEvents","setEventData","setEventCallback","replaceEventCallback","setLoopInterval","glnow","tpnow","startToNow","lastStartTime","StepSequencer","values","doLoop","setValues","transport","callbackUnpackingIndex","setInterval","setCallback","max","setDoLoop","TogglableBox","isToggled","toggle","isActive","display","onClick","nodeTypes","sequencer","noCols","setNoCols","noRows","setNoRows","bangGrid","setBangGrid","currentCols","currentRows","newBangGrid","newCols","col","newRows","stepCursor","setStepCursor","bangOutCallbacks","stepSeq","stepSeqCallback","row","bangGridT","zip","direction","defaultValue","onChange","checked","e","rowI","colI","grid","colI_","rowI_","flipRowCol","urbang","setRunning","triggerUrBang","player","class_","classRef","args","undefined","useNew","Player","lastPlaybackRef","output","lastPb","error","startPlayer","setLoop","fpath","setFPath","set","playerReady","setPlayerReady","load","then","onPressEnter","disabled","audioout","isOn","setOn","mapValues","AddNodePopup","x","y","dissapear","visible","flowGraph","useContext","popup","placeholder","event","blur","autoFocus","onBlur","GraphView","onConnectHandles","log","onElementsRemove","onDragOver","preventDefault","dropEffect","onDrop","parse","project","clientX","clientY","setPopupState","onPaneContextMenu","stopPropagation","pageX","pageY","onLoad","onConnect","deleteKeyCode","variant","gap","defaultFlowConfiguration","zoom","storageKey","StorageController","setGraphConfig","flowConfig","transform","setTransform","getGraphConfig","toObject","saveGraph","localStorage","setItem","loadGraph","config","getItem","resetGraph","Group","gutter","App","span","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document"],"mappings":"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","file":"static/js/main.6aeadc2f.chunk.js","sourcesContent":["\nlet presets = {\n    sampler: []\n}\n\n// Populate presets with samples\nconst collectedNames = ['Clap', 'Cow', 'Hihat1_closed', 'Hihat3_closed', 'Hihat_open', 'Kick', 'Snare', 'Snare3', 'Snare5', 'Clap2', 'Crash', 'Hihat2_closed', 'Hihat4_closed', 'Hihat_open_2', 'Kick2', 'Snare2', 'Snare4']\ncollectedNames.forEach(presetName =>\n    presets.sampler.push({name: `808 ${presetName}`, data: {loop: false, path: `808/${presetName}`}})\n)\n\nexport { presets }","\nimport { Collapse, List } from 'antd';\nimport { presets } from './presets';\n\n\nexport const PresetBrowser = (props) => {\n    return <Collapse style={{margin: 10}}>\n        {Object.keys(presets).map(\n            typeName => <Collapse.Panel header={typeName} key={typeName}>\n                <List size=\"small\"\n\n                    bordered\n                    dataSource={presets[typeName]}\n                    renderItem={item =>\n                        <List.Item\n                            key={item.name}\n                            draggable\n                            onDragStart={ev => {\n                                ev.dataTransfer.setData(\"audio-tool/node-preset\", JSON.stringify({type: typeName, data: item.data}));\n                                ev.dataTransfer.effectAllowed = \"move\";\n                                }}>\n                            {item.name}\n                        </List.Item>} />\n            </Collapse.Panel>\n        )}\n    </Collapse>\n}","\n\nexport class AudioGraph {\n    constructor(){\n        /** Maps id -> audio node */\n        this.nodeMap = {};\n    }\n\n    registerNode = (node, nodeIdentifier) => {\n        this.nodeMap[nodeIdentifier] = node;\n    }\n\n    deregisterNode = (id) => {\n        delete this.nodeMap[id];\n    }\n\n    connectNodes = (id1, id2) => {\n        this.nodeMap[id1].connect(this.nodeMap[id2]);\n    }\n\n    disconnectNodes = (id1, id2) => {\n        this.nodeMap[id1]?.disconnect(this.nodeMap[id2]);\n    }\n\n    isAudioNode = id => {\n        return id in this.nodeMap\n    };\n\n    areConnected = (id1, id2) => {\n        return this.nodeMap[id1].is\n    }\n}\n\n\nexport const globalAudioGraph = new AudioGraph();","\n\nexport class BangGraph {\n    constructor(){\n        /** Maps id -> trigger callback */\n        this.triggereeMap = {};\n        /** Maps id -> trigeree id sets */\n        this.triggererMap = {};\n    }\n\n    registerOutputNode = (nodeIdentifier) => {\n        if(!(nodeIdentifier in this.triggererMap)){\n            this.triggererMap[nodeIdentifier] = new Set();\n        }\n        return this.getTriggerCallbackForOutputNode(nodeIdentifier);\n    }\n\n    getTriggerCallbackForOutputNode = nodeIdentifier => {\n        const callback = (time, data) => (this.triggererMap[nodeIdentifier] ?? new Set()).forEach(\n            triggeree => this.triggereeMap[triggeree](time, data)\n        );\n        return callback;\n    }\n\n    deregisterOutputNode = nodeIdentifier => {\n        this.triggererMap[nodeIdentifier].forEach(inputNode =>\n            this.disconnectNodes(nodeIdentifier, inputNode));\n        delete this.triggererMap[nodeIdentifier];\n    }\n\n    registerInputNode = (nodeIdentifier, callback) => {\n        const id = nodeIdentifier;\n        this.triggereeMap[id] = callback;\n    }\n\n    deregisterInputNode = (id) => {\n        delete this.triggereeMap[id];\n    }\n\n    connectNodes = (id1, id2) => {\n        this.triggererMap[id1].add(id2);\n    }\n\n    disconnectNodes = (id1, id2) => {\n        this.triggererMap[id1]?.delete(id2);\n    }\n\n    isBangNode = id => {\n        return id in this.triggereeMap || id in this.triggererMap;\n    };\n}\n\n\nexport const globalBangGraph = new BangGraph();","import _ from 'lodash';\nimport React, { Component } from 'react';\nimport {v4 as uuidv4 } from 'uuid';\n\nexport const FlowGraphContext = React.createContext({});\n\nexport class FlowGraphProvider extends Component {\n    localStorageKey = \"graph\";\n\n    constructor(props){\n        super(props);\n        this.state = {\n            elements: [],\n            setElements: elements => this.setState({elements}),\n\n            reactFlowInstance: null,\n            setReactFlowInstance: reactFlowInstance => this.setState({reactFlowInstance}),\n\n            createNode: this.createNode,\n            setNodeData: this.setNodeData,\n            getNodeData: this.getNodeData,\n            createEdge: this.createEdge,\n            deleteElement: this.pullElement,\n            deleteEdgesConnectedToHandle: this.deleteEdgesConnectedToHandle\n        }\n    }\n\n    createUniqueId = () => {\n        return uuidv4();\n    }\n\n    pushElement = element => {\n        this.setState(state => ({elements: [...state.elements, element]}));\n    }\n\n    pullElement = element => {\n        this.pullElementById(element.id);\n    }\n\n    pullElementById = id => {\n        this.setState(state => ({elements: _.reject(state.elements, {id})}));\n    }\n\n    pullElementByPredicate = pred => {\n        this.setState(state => ({elements: _.filter(state.elements, el => !pred(el))}));\n    }\n\n    replaceElementById = (id, element) => {\n        this.setState(state => ({elements: state.elements.map(element_ => element_.id === id ? element : element_)}));\n    }\n\n    getElementById = id => {\n        return this.state.elements.find(element => element.id === id);\n    }\n\n    createNode = (type, position, data={}) => {\n        const id = this.createUniqueId();\n        this.pushElement({type, id, position, data});\n    }\n\n    createEdge = (sourceNode, sourceHandle, targetNode, targetHandle, type) => {\n        const id = this.createUniqueId();\n        this.pushElement({id, sourceHandle, targetHandle, source: sourceNode, target: targetNode, type});\n    }\n\n    setNodeData = (id, data) => {\n        const node = this.getElementById(id);\n        this.replaceElementById(id, {...node, data});\n    }\n\n    getNodeData = id => {\n        const node = this.getElementById(id);\n        return node.data;\n    }\n\n    deleteEdgesConnectedToHandle = handleId => {\n        this.pullElementByPredicate(el => el.sourceHandle === handleId || el.targetHandle === handleId);\n    }\n\n    render = () => {\n        return <FlowGraphContext.Provider value={this.state}>\n            {this.props.children}\n        </FlowGraphContext.Provider>\n    }\n\n}","/**\n * Stores the \"time resolution\" in terms of pulses per second.\n * Stored in two fields:\n * * bpm: beats per minute\n * * ppb: pulses per beat\n */\nexport class TimeResolution{\n    constructor(bpm, ppb){\n        this.bpm = bpm;\n        this.ppb = ppb;\n\n        this.pulsePerSecond = ppb*bpm/60;\n        this.secondPerPulse = 1/this.pulsePerSecond;\n    }\n}\n\n/** \n * Utility class to convert to & from different time formats,\n * as well as comibining and comparing different times.\n * \n * All combination and comparison operations assume the same TimeResultion.\n * \n * Stores time in terms of pulses, hence requires TimeResolution as an argument.\n*/\nexport class Time {\n    constructor(pulse, res){\n        this.pulse = pulse;\n        this.res = res;\n    }\n\n    static fromSeconds = (seconds, res) => {\n        const remainder = seconds % res.secondPerPulse;\n        const pulse = Math.floor(seconds * res.pulsePerSecond) + (remainder ? 1 : 0)\n        return new Time(pulse, res);\n    }\n\n    toSeconds = () => {\n        return this.pulse/this.res.pulsePerSecond;\n    }\n\n    static fromPulse = (pulse, res) => {\n        return new Time(pulse, res);\n    }\n\n    toPulse = () => {\n        return this.pulse;\n    }\n\n    static fromBarNotation = (notation, res) => {\n        let pulse = 0;\n        notation.split(\":\").forEach((v, i) =>{\n            const pulserPerPart = Math.floor(res.ppb*4/(1<<(i*2)));\n            pulse += Number(v)*pulserPerPart;\n        });\n        return new Time(pulse, res);\n    }\n\n    add = time => {\n        return new Time(this.pulse + time.pulse, this.res);\n    }\n\n    subtract = time => {\n        return new Time(this.pulse - time.pulse, this.res);\n    }\n\n    multiply = factor => {\n        return new Time(this.pulse * factor, this.res);\n    }\n\n    isBefore = time => {\n        return this.toSeconds() < time.toSeconds();\n    }\n\n    isAfter = time => {\n        return this.toSeconds() > time.toSeconds();\n    }\n\n        \n    isOnOrBefore = time => {\n        return !this.isAfter(time);\n    }\n\n    isOnOrAfter = time => {\n        return !this.isBefore(time);\n    }\n\n    isNever = () => {\n        return this.pulse === Number.POSITIVE_INFINITY;\n    }\n}\n\n/**\n * Takes a scheduler instead of a TimeResolution as an argument,\n * from which time resolution is then taken.\n * \n * Also allows scheduling of events on the scheduler for a schduler-time t using\n * * t.schedule(callback, data); and\n * * t.schedulerLater(callback, data, deltaTime);\n */\nexport class SchedulerTime extends Time {\n    constructor(pulse, scheduler){\n        super(pulse, scheduler.getResolution());\n        this.scheduler = scheduler;\n    }\n\n    static fromTime = (time, scheduler) => {\n        return new SchedulerTime(time.toPulse(), scheduler);\n    }\n\n    static fromSeconds = (seconds, scheduler) => {\n        const time = Time.fromSeconds(seconds, scheduler.getResolution());\n        return SchedulerTime.fromTime(time, scheduler);\n    }\n\n    static fromBarNotation = (notation, scheduler) => {\n        const time = Time.fromBarNotation(notation, scheduler.getResolution());\n        return SchedulerTime.fromTime(time, scheduler);\n    }\n\n    static fromPulse = (pulse, scheduler) =>{\n        const time = Time.fromPulse(pulse, scheduler.getResolution());\n        return SchedulerTime.fromTime(time, scheduler);\n    }\n\n    schedule = (callback, data) => {\n        return this.scheduler.schedule(callback, this, data);\n    }\n\n    scheduleLater = (callback, time, data) => {\n        return this.add(time).schedule(callback, data);\n    }\n\n    scheduleDraw = callback => {\n        this.scheduler.scheduleDraw(callback, this);\n    }\n\n    // To-Do: Implement s.t. we don't need to rewrite add & multiply\n    add = time => {\n        return new SchedulerTime(this.pulse + time.pulse, this.scheduler);\n    }\n\n    multiply = factor => {\n        return new SchedulerTime(this.pulse * factor, this.scheduler);\n    }\n\n    subtract = time => {\n        return new SchedulerTime(this.pulse - time.pulse, this.scheduler);\n    }\n\n    mod = time => {\n        return new SchedulerTime(this.pulse % time.pulse, this.scheduler);\n    }\n\n    toString = () => {\n        if(this.pulse === Number.POSITIVE_INFINITY)\n            return \"time(Infinity)\";\n        else\n            return `time(pulse=${this.pulse})`;\n    }\n\n    justBefore = () => {\n        return new SchedulerTime(this.pulse-1, this.scheduler);\n    }\n\n    justAfter = () => {\n        return new SchedulerTime(this.pulse+1, this.scheduler);\n    }\n\n}","\nimport FastPriorityQueue from 'fastpriorityqueue';\nimport { useEffect } from 'react';\nimport * as Tone from 'tone';\nimport { Emitter } from 'tone';\nimport { assert } from 'tone/build/esm/core/util/Debug';\nimport { SchedulerTime, TimeResolution, Time } from './time';\n\n\nexport class PreciseScheduler extends Emitter{\n    constructor({\n        ppb = 64, // pulse per beat, i.e. time resolution\n        bpm = 120, // beats per minute, i.e. speed\n        lookAhead = 12, // ms to schedule in advance\n    }={} ){\n        super();\n        // Event: {time, id}\n        this.eventQueue = new FastPriorityQueue((ev1, ev2) => ev1.time.isBefore(ev2.time));\n        this.resolution = new TimeResolution(bpm, ppb);\n        this.dispatchTimeoutID = null;\n\n        this.p = pulse => SchedulerTime.fromPulse(pulse, this)\n        this.s = seconds => SchedulerTime.fromSeconds(seconds, this)\n        this.b = barNot => SchedulerTime.fromBarNotation(barNot, this)\n\n        // {id: callback}\n        this.callbackRegister = {}\n        // {id: data}\n        this.dataRegister = {}\n        // counter to get unique event ids\n        this.lastScheduledEventId = 0\n\n        this.doStop = false;\n\n        this.lookAhead = this.s(lookAhead*0.001);\n    }\n\n    debug = msg => {\n        console.debug(`[Scheduler]{${this.now().toPulse()}}: `, msg);\n    }\n\n    isRunning = () => {\n        return !this.doStop;\n    }\n\n    getResolution = () => this.resolution;\n\n    getNewEventId = () => {\n        this.lastScheduledEventId += 1;\n        return this.lastScheduledEventId;\n    }\n\n    _rescheduleDispatch = () => {\n        clearTimeout(this.dispatchTimeoutID);\n        if(!this.doStop)\n            this.dispatchTimeoutID = setTimeout(this.dispatch, this.lookAhead.toSeconds()/2);\n        else\n            this.dispatchTimeoutID = null;\n    }\n\n    clear = () =>{\n        while(!this.eventQueue.isEmpty()) this.eventQueue.poll();\n    }\n\n    stop = () => {\n        this.doStop = true;\n        this.clear();\n        this.emit(\"stop\");\n    }\n\n    start = () => {\n        this.doStop = false;\n        this.emit(\"start\");\n        this.dispatch();\n    }\n\n    dispatch = () =>{\n        while(\n            !this.doStop &&\n            !this.eventQueue.isEmpty() && \n            this.eventQueue.peek().time.isBefore(this.now().add(this.lookAhead))\n            ){\n                const {time, id} = this.eventQueue.poll();\n                const callback = this.callbackRegister[id];\n                const data = this.dataRegister[id];\n\n                this.debug(`Dispatching event with id ${id} scheduled for pulse [${time}]`)\n                callback(time, data);\n                this._cleanUp(id);\n        }\n        this._rescheduleDispatch();\n    }\n\n    schedule = (callback, t, data) =>{\n        assert(t instanceof Time, \"Scheduling time must be Time object.\");\n        const id = this.getNewEventId();\n        this.eventQueue.add({time: t, id});\n        this.callbackRegister[id] = callback;\n        this.dataRegister[id] = data;\n        this.debug(`Scheduled event with id ${id} for pulse  [${t.toPulse()}]`)\n        return id;\n    }\n\n    unschedule = eventId => {\n        this.debug(`Unscheduled event ${eventId}`);\n        if(!(eventId) in this.callbackRegister)\n            console.warn(\"Removed inexistant event with id \", eventId);\n        this.eventQueue.removeOne(ev => ev.id === eventId);\n        this._cleanUp(eventId);\n    }\n\n    /* Removes all data associated with the eventId. Doesn't touch eventQueue. */\n    _cleanUp = eventId => {\n        delete this.callbackRegister[eventId];\n        delete this.dataRegister[eventId];\n    }\n\n    replaceScheduledCallback = (id, callback) => {\n        assert(id in this.callbackRegister, \"Tried replacing data of inexistant event\");\n        this.callbackRegister[id] = callback;\n    }\n\n    replaceEventData = (id, data) => {\n        assert(id in this.dataRegister, \"Tried replacing data of inexistant event\");\n        this.dataRegister[id] = data;\n    }\n\n    now = () => {\n        return this.s(Tone.getContext().now());\n    }\n\n    scheduleDraw = (callback, time) => {\n        Tone.Draw.schedule(callback, time.toSeconds());\n    }\n\n}\n\nexport const globalScheduler = new PreciseScheduler();\n\nexport const {b, s, p} = globalScheduler;\nexport const never = s(Number.POSITIVE_INFINITY);\n\nexport const useOnGlobalSchedulerStart = callback => {\n    useEffect(() => globalScheduler.on(\"start\", callback), []);\n}\n\nexport const useOnGlobalSchedulerStop = callback => {\n    useEffect(() => globalScheduler.on(\"stop\", callback), []);\n}","import { useEffect, useState } from 'react';\nimport { getBezierPath } from 'react-flow-renderer';\nimport { globalScheduler } from '../scheduler/scheduler';\nimport { globalAudioGraph } from './audio';\nimport { globalBangGraph } from './bang';\n\n\nconst CustomPath = ({sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, style, id}) => {\n    const d = getBezierPath({sourceX, sourceY, sourcePosition, targetX, targetY, targetPosition});\n    return <path {...{d, style, id}} />\n}\n\nexport const AudioEdge = ({selected, ...props}) => {\n    useEffect(() => {globalAudioGraph.connectNodes(props.sourceHandleId, props.targetHandleId);\n        return () => globalAudioGraph.disconnectNodes(props.sourceHandleId, props.targetHandleId)}, []);\n    return <CustomPath {...props} style={{strokeWidth: 3, fill: \"none\", stroke: selected ? \"#555\" : \"#cccc\"}} />\n    }\n\n\nexport const BangEdge = ({selected, ...props}) => {\n    // Connect input & output\n    useEffect(() => {globalBangGraph.connectNodes(props.sourceHandleId, props.targetHandleId);\n            return () => globalBangGraph.disconnectNodes(props.sourceHandleId, props.targetHandleId)}, []);\n\n    // make edge flash on bang\n    const [flash, setFlash] = useState(false);\n    const doFlash = (time) => globalScheduler.scheduleDraw(() => {setFlash(true); setTimeout(() => setFlash(false), 100)}, time);\n    const edgeIdentifier = `edge(${props.sourceHandleId}-${props.targetHandleId})`;\n    useEffect(() => {globalBangGraph.registerInputNode(edgeIdentifier, doFlash);\n        return () => globalBangGraph.deregisterInputNode(edgeIdentifier)}, []);\n    useEffect(() => {globalBangGraph.connectNodes(props.sourceHandleId, edgeIdentifier);\n        return () => globalBangGraph.disconnectNodes(props.sourceHandleId, edgeIdentifier)}, [])\n    const color = flash ? \"orange\" : (selected ? \"#555\" : \"#ccc\");\n    \n    return <CustomPath {...props} style={{strokeWidth: 3, fill: \"none\", stroke: color}} />\n}","import { AudioEdge, BangEdge } from \"../graph/edges\";\n\nexport const edgeTypes = {\n    audio: AudioEdge,\n    bang: BangEdge\n}","import { useRef, useEffect } from 'react';\n\nexport const usePrevious = (value, firstValue) => {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current ?? firstValue;\n}\n\n\n/** \n * Works like useEffect but passes the previous value to the callback.\n * The first time the callback is called, as well as before the component unmounts,\n * the first value is used.\n */\nexport const useEffectWithPrevious = (callback, currentValue, firstValue) => {\n    const previousValue = usePrevious(currentValue, firstValue);\n    useEffect(() => callback(previousValue), [currentValue]);\n    useEffect(() => () => callback(firstValue), []);\n}\n\n/**\n * Convencience hook to instanciate classes inside functional react components.\n * \n * Instead of \n * ```\n * const fb = new FooBar(x, y, z);\n * ```\n * Simply write\n * ```\n * const fb = useNew(FooBar)(x, y, z);\n * ```\n * \n */\nexport const useNew = (class_) => {\n    const classRef = useRef();\n    return (...args) => {\n      if(classRef.current === undefined)\n        classRef.current = new class_(...args);\n      return classRef.current;\n    }\n}","import { useEffect, useState, useCallback, useMemo } from 'react';\nimport { Handle as FlowHandle, useUpdateNodeInternals } from 'react-flow-renderer';\n\nimport { globalBangGraph } from './bang';\n\nconst BaseHandle = props =>{\n    return <FlowHandle {...props} style={{...props.style, width: 20, height: 20, zIndex: -1, ...props.style}} />\n}\n\nconst posToBorderRadius = {\n    top: \"100% 100% 0 0\",\n    left: \"100% 0 0 100%\",\n    right: \"0 100% 100% 0\",\n    bottom: \"0 0 100% 100%\"\n}\nconst AudioHandle = (props) => \n    <BaseHandle {...props} style={{borderRadius: posToBorderRadius[props.position], backgroundColor: \"lightblue\"}} />\n\n\nconst SourceBangHandle = (props) => {\n    const [isBanging, setBanging] = useState(false);\n    const bang = useCallback((time) => time.scheduleDraw(() => {setBanging(true); setTimeout(() => setBanging(false), 100)}), []);\n    const bangReciverNodeId = useMemo(() =>  `bangReceiverForHandleFlashing(${props.id})`, []);\n\n    useEffect(() => {globalBangGraph.registerInputNode(bangReciverNodeId, bang);\n        return () => globalBangGraph.deregisterInputNode(bangReciverNodeId)}, []);\n    useEffect(() => {globalBangGraph.connectNodes(props.id, bangReciverNodeId);\n        return () => globalBangGraph.disconnectNodes(props.id, bangReciverNodeId)}, [])\n    return <BaseHandle {...props} style={{borderRadius: 0, backgroundColor: isBanging ? \"orange\" : \"grey\", border: 0, ...props.style}} />\n}\n\nconst TargetBangHandle = (props) => {\n    return <BaseHandle {...props} style={{borderRadius: 0, backgroundColor: \"lightgrey\", border: 0, ...props.style}} />\n}\n\nconst BangHandle = (props) => {\n    if(props.type === \"source\")\n        return <SourceBangHandle {...props} />\n    else\n        return <TargetBangHandle {...props} />\n}\n\n    \n\nconst handleKinds = {\n    audio: AudioHandle,\n    bang: BangHandle\n}\n\n/** Returns a handle from handleKinds according to \"kind\" prop. Pass parentId if handle is created dynamically. */\nexport const Handle = ({kind, parentId, ...props}) => {\n\n    // Required to make react-flow update internal state on dynamic handle creation\n    const updateNodeInternals = useUpdateNodeInternals();\n    useEffect(() => updateNodeInternals(parentId), [props.style]);\n\n    if(!(kind in handleKinds)){\n        throw `Unknown handle kind ${kind}`\n    } else {\n        const SelectedHandle = handleKinds[kind];\n        return <SelectedHandle {...props} />\n    }\n}\n\n","import { SaveOutlined } from '@ant-design/icons';\nimport { Badge } from 'antd';\nimport _ from 'lodash';\nimport { Component, useEffect, useMemo, useState } from 'react';\nimport usePrevious, { useEffectWithPrevious } from '../common/hooks';\nimport { globalAudioGraph } from './audio';\nimport { globalBangGraph } from './bang';\nimport { FlowGraphContext } from './flow';\nimport { Handle } from './handles';\n/** Contains the instances of all nodes, globally */\nconst globalAllNodes = new Set();\n/** Returns list of all nodes as react-flow elements */\nexport const getAllNodesAsReactFlowElements = () => Array.from(globalAllNodes).map(node => node.getAsReactFlowElement());\n\n/** Returns the node wrapped in the standard node container, with borders, handles, hooks, etc. */\nexport const insideNodeContainer = (Node, onHandleRemove) => {\n    return class extends Component {\n        static contextType = FlowGraphContext;\n        constructor(props){\n            super(props);\n            this.id = props.id;\n            this.type = props.type;\n            this.state = {\n                title: \"\",\n                handles: [],\n            }\n            \n        }\n\n        pushHandle = (id, kind, type, position) => {\n            const handle = {id, kind, type, position};\n            this.setState(state => ({handles: [...state.handles, handle]}));\n        }\n\n        pullHandle = id => {\n            this.setState(state => ({handles: _.reject(state.handles, {id})}));\n            this.context.deleteEdgesConnectedToHandle(id);\n        }\n\n        toAudioNodeIdentifier = handleName =>\n            `audioHandle(name='${handleName}', node='${this.id}')`;\n        \n        toBangInputNodeIdentifier = handleName => \n            `bangInputHandle(name='${handleName}', node='${this.id}')`;\n        \n        toBangOutputNodeIdentifier = handleName => \n            `bangOutputHandle(name='${handleName}', node='${this.id}')`\n\n        addAudioInputHandle = (audioNode, handleName, position=\"top\") => {\n            const nodeIdentifier = this.toAudioNodeIdentifier(handleName);\n            globalAudioGraph.registerNode(audioNode, nodeIdentifier);\n            this.pushHandle(nodeIdentifier, \"audio\", \"target\", position);\n            return nodeIdentifier;\n        }\n\n        removeAudioInputHandle = handleName => {\n            const nodeIdentifier = this.toAudioNodeIdentifier(handleName);\n            globalAudioGraph.deregisterNode(nodeIdentifier);\n            this.pullHandle(nodeIdentifier);\n        }\n\n        addAudioOutputHandle = (audioNode, handleName, position=\"bottom\" ) => {\n            const nodeIdentifier = this.toAudioNodeIdentifier(handleName);\n            globalAudioGraph.registerNode(audioNode, nodeIdentifier);\n            this.pushHandle(nodeIdentifier, \"audio\", \"source\", position);\n            return nodeIdentifier;\n        }\n\n        removeAudioOutputHandle = handleName => {\n            const nodeIdentifier = this.toAudioNodeIdentifier(handleName);\n            globalAudioGraph.deregisterNode(nodeIdentifier);\n            this.pullHandle(nodeIdentifier);\n        }\n\n        addBangInputHandle = (callback, handleName, position=\"left\") => {\n            const nodeIdentifier = this.toBangInputNodeIdentifier(handleName);\n            globalBangGraph.registerInputNode(nodeIdentifier, callback);\n            this.pushHandle(nodeIdentifier, \"bang\", \"target\", position);\n            return nodeIdentifier;\n        }\n\n        removeBangInputHandle = handleName => {\n            const nodeIdentifier = this.toBangInputNodeIdentifier(handleName);\n            globalBangGraph.deregisterInputNode(nodeIdentifier);\n            this.pullHandle(nodeIdentifier);\n        }\n\n        addBangOutputHandle = (handleName, position=\"right\") => {\n            const nodeIdentifier = this.toBangOutputNodeIdentifier(handleName);\n            const callback = globalBangGraph.registerOutputNode(nodeIdentifier);\n            this.pushHandle(nodeIdentifier, \"bang\", \"source\", position);\n            return [nodeIdentifier, callback];\n        }\n\n        removeBangOutputHandle = handleName => {\n            const nodeIdentifier = this.toBangInputNodeIdentifier(handleName);\n            globalBangGraph.deregisterOutputNode(nodeIdentifier);\n            this.pullHandle(nodeIdentifier);\n        }\n\n        componentDidMount = () => {\n            globalAllNodes.add(this);\n        }\n\n        componentWillUnmount = () => {\n           globalAllNodes.delete(this);\n        }\n\n        getAsReactFlowElement = () => {\n            return {\n                data: this.getData(),\n                id: this.id,\n                type: this.type\n            };\n        }\n\n        render(){\n            const node = <Node \n                key={this.id}\n\n                useTitle={title => useEffect(() => this.setState({title}), [title])}\n\n                useData={(initialData, dataId, doClear) => {\n                    const data = (this.props.data ?? {})[dataId] ?? initialData;\n                    const [r, setR] = useState(false);\n                    const forceRerender = () => setR(!r);\n                    const setData = dataOrF => {\n                        const newData = dataOrF instanceof Function ? dataOrF(data) : dataOrF;\n                        this.context.setNodeData(this.id, {...this.props.data, [dataId]: newData});\n                        forceRerender();\n\n                    };\n                    return [data, setData];\n                }}\n\n                useAudioInputHandle={\n                    (audioNode, handleName, position) => {\n                        useEffect(() => {this.addAudioInputHandle(audioNode, handleName, position);\n                            return () => this.removeAudioInputHandle(handleName)}, []);\n                    }\n                }\n\n                useAudioOutputHandle={\n                    (audioNode, handleName, position) => {\n                        useEffect(() => {this.addAudioOutputHandle(audioNode, handleName, position);\n                            return () => {this.removeAudioOutputHandle(handleName)}}, []);\n                    }\n                }\n\n                useBangInputHandle={\n                    (callback, handleName, position) => {\n                        useEffect(() => {this.addBangInputHandle(callback, handleName, position);\n                            return () => {this.removeBangInputHandle(handleName)}}, []);\n                    }\n                }\n\n                useBangOutputHandle={\n                    (handleName, position=\"right\") => {\n                        const [nodeIdentifier] = useState(() => this.toBangOutputNodeIdentifier(handleName));\n                        const [callback] = useState(() => globalBangGraph.registerOutputNode(nodeIdentifier));\n                        useEffect(() => {this.pushHandle(nodeIdentifier, \"bang\", \"source\", position);\n                            return () => globalBangGraph.deregisterOutputNode(nodeIdentifier)}, []);\n                        return callback;\n                    }\n                }\n\n                useBangOutputHandles={\n                    (numHandles, handleNamePrefix=\"bang-handle\", position=\"right\") => {\n                        // Get identifier for every node\n                        const handleNames = useMemo(() => [...Array(numHandles).keys()].map(i => `${handleNamePrefix}-${i}`), [numHandles]);\n                        const nodeIdentifiers = useMemo(() => handleNames.map(handleName => this.toBangOutputNodeIdentifier(handleName)), [handleNames]);\n                        const callbacks = useMemo(() => nodeIdentifiers.map(identifier => globalBangGraph.getTriggerCallbackForOutputNode(identifier)), [nodeIdentifiers]);\n\n                        useEffectWithPrevious((previousNodeIdentifiers) => {\n                            const newNodeIdentifiers = nodeIdentifiers.slice(previousNodeIdentifiers.length);\n                            const discardingNodeIdentifiers = previousNodeIdentifiers.slice(nodeIdentifiers.length);\n                            newNodeIdentifiers.map(nodeIdentifier => {\n                                globalBangGraph.registerOutputNode(nodeIdentifier);\n                                this.pushHandle(nodeIdentifier, \"bang\", \"source\", \"right\")\n                            });\n                            discardingNodeIdentifiers.map(nodeIdentifier => {\n                                globalBangGraph.deregisterOutputNode(nodeIdentifier);\n                                this.pullHandle(nodeIdentifier);\n                            });\n                        }, nodeIdentifiers, []);\n                        return callbacks;\n                    }\n                }\n                />\n\n            const outerStyle = {\n                border: `1px solid ${this.props.selected ? \"black\" : \"lightgrey\"}`,\n                minWidth: \"30px\",\n                minHeight: \"30px\",\n                fontSize: \"smaller\",\n                borderRadius: \"2px\",\n                boxShadow: \"0px 0px 1px lightgrey\",\n                backgroundColor: \"white\",\n                margin: \"10px\"\n            }\n\n            const titleStyle = {\n                backgroundColor: \"rgb(235, 235, 235)\",\n                fontSize: \"x-small\",\n                padding: \"2px\",\n                paddingLeft: \"6px\",\n                minHeight: \"7px\"\n            }\n\n            const contentStyle = {\n                padding: \"3px\",\n                cursor: \"pointer\"\n            }\n\n            const savePresetBadge = <span style={{paddingLeft: 5}}><Badge count={<SaveOutlined />} onClick={() => console.log(this.data)}/></span>\n\n            const minOffset = 40;\n            const offsetStep = 22;\n            const offsets = {\n                left: minOffset,\n                right: minOffset\n            }\n            const getOffsetForHandleOfSide = side => {\n                const offset = offsets[side];\n                offsets[side] += offsetStep;\n                return `${offset}px`;\n            }\n            \n            return <div style={outerStyle} key={this.id}>\n                {this.state.handles.map(props => <Handle {...props} key={props.id} parentId={this.id} style={{top: getOffsetForHandleOfSide(props.position)}} />)}\n                <div style={titleStyle}>{this.state.title}</div>\n                <div style={contentStyle} className=\"nodrag\">{node}</div>\n            </div>\n        }\n    }\n}","\nimport { InputNumber } from \"antd\";\n\nexport const NumberInputer = (props) => \n    <InputNumber min={1} size=\"small\" precision={0} step={1} {...props} style={{width: 50, ...props.style}}/>","import { globalScheduler, never, p, s } from \"./scheduler\";\nimport { TimeResolution } from \"./time\";\nimport FastPriorityQueue from \"fastpriorityqueue\";\nimport { TransportTime } from \"tone\";\nimport { TickSignal } from \"tone/build/esm/core/clock/TickSignal\";\nimport { theWindow } from \"tone/build/esm/core/context/AudioContext\";\nimport { assert } from \"tone/build/esm/core/util/Debug\";\nimport { tsImportEqualsDeclaration } from \"@babel/types\";\n\n\n/**\n * Transport can be used to have a \"fixed\" timeline with events that are kept even if the\n * global scheduler is stopped.\n * \n * It can be started or stopped. Note that start & stop do NOT behave as though they were on the \n * timeline; instead, they're \"ephemeral\". Stop immediately clears all events after the provided time;\n * \"start\" immediately clears & schedules all events.\n * \n * If start / stop need to behave as though they were on a timleine, they need to be put on\n * a separate, different transport that schedules them.\n * \n * It can be looped by a \"loopInterval\", which will schedule a new \"start\" event ever interval time.\n * \n * It's analogous to a MIDI file which can be scheduled to start & stop. at any point on the global scheduler\n * (only that data associated with every MIDI event is arbitrary).\n * \n * TODO: * Add ability to play back with \"offset\".\n * TODO: * Make events scheduled beyond interval not be triggered\n */\nexport class Transport {\n    constructor(\n        loopInterval,\n    ){\n        this.tpEvents = {} // {tpid: {callback, tptime, data}}\n        this.tp2glEvents = {} // {tpid: {glid, gltime}}\n\n        this.interval = loopInterval ?? never;\n        // Keeps id of next control event, so it can be unscheduled if needed.\n        this.nextControlEventId = null;\n        this.glStartTime = never;\n\n        globalScheduler.on(\"stop\", () => this.stop(s(0)));\n    }\n    getUniqueEventId = () => {\n        this.eventIdCounter = (this.eventIdCounter ?? 0) + 1;\n        return this.eventIdCounter;\n    }\n\n\n    schedule = (tpid) => {\n        assert(!(this.isScheduled(tpid)), \"Tried scheduling already schedueld event\");\n        // Calculate global time\n        const {tptime, callback, data} = this.tpEvents[tpid];\n        const gltime = tptime.add(this.glStartTime);\n        // Create callback that also deregisters this event\n        const deregisterAndCall = (time, data) => {\n            delete this.tp2glEvents[tpid];\n            callback(time, data);\n        }\n        const glid = gltime.schedule(deregisterAndCall, data);\n        // Register this event\n        this.tp2glEvents[tpid] = {glid, gltime};\n    }\n\n    start = time => {\n        this.glStartTime = time;\n        // Reschedule all events\n        Object.keys(this.tpEvents).forEach(tpid => {\n            if(this.isScheduled(tpid))\n                this.unschedule(tpid);\n            this.schedule(tpid);\n        });\n        \n        // Unschedule other control event\n        if(this.nextControlEventId)\n            globalScheduler.unschedule(this.nextControlEventId);\n\n        // Schedule start if interval < infinity\n        if(this.interval.isBefore(never))\n            this.nextControlEventId = time.add(this.interval).schedule(this.start);\n    }\n\n    stop = time => {\n        // Unschedule next control event\n        if(this.nextControlEventId)\n            globalScheduler.unschedule(this.nextControlEventId);\n\n        // Unschedule all events after stop event\n        Object.entries(this.tp2glEvents).forEach(([tpid, {gltime}]) => {\n            if(gltime.isAfter(time) && this.isScheduled(tpid)){\n                this.unschedule(tpid)\n            }\n        });\n    }\n\n    isRunning = () => {\n        return this.glStartTime.isBefore(globalScheduler.now());\n    }\n\n    isScheduled = tpid => {\n        return tpid in this.tp2glEvents;\n    }\n\n    addEvent = (tptime, callback, data) => {\n        const tpid = this.getUniqueEventId();\n        this.tpEvents[tpid] = {callback, data, tptime};\n        // Check if transport is currently running & event hasn't yet passed\n        if(this.isRunning() && this.getTpNow().isOnOrBefore(tptime)){\n            // If so, then schedule this event.\n            this.schedule(tpid);\n        }\n    }\n\n    removeEvent = tpid => {\n        if(this.isScheduled(tpid)){\n            this.unschedule(tpid);\n        }\n        delete this.tpEvents[tpid];\n    }\n\n    removeAllEvents = () => {\n        Object.keys(this.tpEvents).forEach(tpid => this.removeEvent(tpid));\n    }\n\n    setEventData = (tpid, data) => {\n        if(this.isScheduled(tpid)){\n            const {glid} = this.tp2glEvents[tpid];\n            globalScheduler.replaceEventData(glid, data);\n        }\n\n        this.tpEvents[tpid] = {...this.tpEvents[tpid], data};\n    }\n\n    setEventCallback = (tpid, callback) => {\n        if(this.isScheduled(tpid)){\n            const {glid} = this.tp2glEvents[tpid];\n            globalScheduler.replaceEventCallback(glid, callback);\n        }\n\n        this.tpEvents[tpid] = {...this.tpEvents[tpid], callback};\n    }\n\n    setLoopInterval = interval => {\n        this.interval = interval;\n        // Remove next control event (assumed to be \"start\") // TODO\n        if(this.nextControlEventId){\n            globalScheduler.unschedule(this.nextControlEventId);\n        }\n\n        // If the loop interval is finite and we're running\n        if(this.interval.isBefore(never) && this.isRunning()){\n            const glnow = globalScheduler.now();\n            const tpnow = this.getTpNow(glnow);\n            // Set glStartTime to last start before current transport cursor\n            const startToNow = glnow.subtract(this.glStartTime);\n            const lastStartTime = glnow.subtract(startToNow.mod(interval));\n            this.glStartTime = lastStartTime;\n            // Reschedule all events\n            Object.keys(this.tp2glEvents).forEach(tpid => this.unschedule(tpid));\n            Object.entries(this.tpEvents).forEach(([tpid, {tptime}]) => {\n                if(tptime.isOnOrAfter(tpnow))\n                    this.schedule(tpid);\n            })\n            // Schedule next start\n            this.nextControlEventId = lastStartTime.add(interval).schedule(this.start);\n        }\n    }\n\n    getTpNow = (glnow=globalScheduler.now()) => {\n        return glnow.subtract(this.glStartTime);\n    }\n    \n    unschedule = tpid => {\n        const {glid} = this.tp2glEvents[tpid];\n        globalScheduler.unschedule(glid);\n        delete this.tp2glEvents[tpid];\n    }\n\n\n}\n\nexport class StepSequencer{\n    constructor(callback, interval, values=[], doLoop=true){\n        this.callback = callback;\n        this.interval = interval;\n        this.values = values;\n        this.doLoop = doLoop;\n\n        this.transport = new Transport();\n\n        // Update transport by setting all values also through setters\n        this.setInterval(interval);\n        this.setDoLoop(doLoop);\n        this.setCallback(callback);\n        this.setValues(values);\n    }\n\n    debug = msg => {\n        console.debug(`[StepSequencer]{${globalScheduler.now().toPulse()}} ${msg}`);\n    }\n\n    setValues = values => {\n        this.debug(\"Set new values\");\n        this.values = values;\n        this.transport.removeAllEvents();\n        \n        const callbackUnpackingIndex = (time, {v, i}) => this.callback(time, v, i);\n        this.values.forEach((v, i) => \n            this.transport.addEvent(this.interval.multiply(i), callbackUnpackingIndex, {v, i})\n        );\n        this.setInterval(this.interval);\n    }\n\n    setCallback = callback => {\n        this.callback = callback;\n    }\n\n    setInterval = interval => {\n        this.interval = interval;\n        if(this.doLoop)\n            this.transport.setLoopInterval(this.interval.multiply((Math.max(1, this.values.length))));\n        else\n            this.transport.setLoopInterval(never);\n    }\n\n    setDoLoop = doLoop => {\n        this.doLoop = doLoop;\n        this.setInterval(this.interval);\n    }\n\n    \n\n    start = time => this.transport.start(time);\n    stop = time => this.transport.stop(time);\n}","import { Checkbox, Space } from \"antd\";\nimport _ from 'lodash';\nimport { useCallback, useEffect, useState } from \"react\";\nimport { NumberInputer } from \"../gui/gui\";\nimport { b, useOnGlobalSchedulerStop } from '../scheduler/scheduler';\nimport { StepSequencer } from \"../scheduler/sequencers\";\n\nconst TogglableBox = ({isToggled, toggle, isActive}) =>\n    <div style={{\n        width: 20,\n        height: 20,\n        border: `4px solid ${isActive ? \"orange\" : \"transparent\"}`,\n        backgroundColor: isToggled ? \"#555\"  : \"#bbb\",\n        margin: 2,\n        padding: 0,\n        display: \"inline-block\",\n        borderRadius: \"1px\"\n    }} \n    onClick={toggle}/>\n\n\n\nexport const Sequencer = ({useData, useBangInputHandle, useBangOutputHandles, useTitle}) => {\n    useTitle(\"Sequencer\");\n\n    const [noCols, setNoCols] = useData(16, \"no-cols\");\n    const [noRows, setNoRows] = useData(2, \"no-rows\");\n    // bangGrid[col][row]\n    const [bangGrid, setBangGrid] = useData(\n        Array(noCols).fill().map(() => Array(noRows).fill(false)), \"bang-grid\"\n    )\n\n    useEffect(() => {\n        setBangGrid(bangGrid => {\n            const currentCols = bangGrid.length;\n            const currentRows = bangGrid[0].length;\n            let newBangGrid = [...bangGrid];\n            if(currentCols < noCols){\n                const newCols = Array(noCols-currentCols).fill().map(() => Array(currentRows).fill(false));\n                newBangGrid = [...bangGrid, ...newCols];\n            } else if (currentCols > noCols){\n                newBangGrid = newBangGrid.slice(0, noCols);\n            }\n\n            if(currentRows < noRows){\n                newBangGrid = newBangGrid.map(col => {\n                    const newRows = Array(noRows - currentRows).fill(false);\n                    return [...col, ...newRows];\n                })\n            } else if (currentRows > noRows){\n                newBangGrid = newBangGrid.map(col => {\n                    return col.slice(0, noRows);\n                })\n\n            }\n            return newBangGrid;\n\n        })\n    }, [noCols, noRows])\n\n    const flipRowCol = (rowI, colI) =>\n        setBangGrid(grid => grid.map((col, colI_) => colI_ !== colI ? col : col.map((row, rowI_) => rowI_ !== rowI ? row : !row))); \n    const [stepCursor, setStepCursor] = useState(-1);\n    const bangOutCallbacks = useBangOutputHandles(noRows, \"seq-out\");\n\n    const [stepSeq] = useState(() => new StepSequencer((() => {}), b(\"0:0:1\")));\n    const stepSeqCallback = useCallback((time, col, i) => {\n        col.map((value, row) => {\n            if(value)\n                bangOutCallbacks[row](time);\n        });\n        time.scheduleDraw(() => setStepCursor(i));\n    }, [bangOutCallbacks]);\n\n    useBangInputHandle((time) => stepSeq.start(time), \"sequencer-start\");\n    useEffect(() => stepSeq.setValues(bangGrid), [bangGrid]);\n    useEffect(() => stepSeq.setCallback(stepSeqCallback), [stepSeqCallback]);\n\n    const [doLoop, setDoLoop] = useData(true, \"do-loop\");\n    useEffect(() => stepSeq.setDoLoop(doLoop), [doLoop]);\n\n    useOnGlobalSchedulerStop(() => setStepCursor(-1));\n    const bangGridT = _.zip(...bangGrid);\n    return <>\n            <Space direction=\"horizontal\" style={{paddingLeft: 2}}>\n                <NumberInputer defaultValue={noRows} onChange={v => setNoRows(v)} /> x\n                <NumberInputer defaultValue={noCols} onChange={v => setNoCols(v)} />\n                <Checkbox checked={doLoop} onChange={e => setDoLoop(e.target.checked)}/>Loop\n            </Space>\n            {bangGridT.map((row, rowI) =>\n                        <div key={rowI}>\n                            {row.map((value, colI) =>\n                                <TogglableBox isToggled={value} toggle={() => flipRowCol(rowI, colI)} key={colI} isActive={stepCursor===colI}/>\n                                )}\n                        </div>)\n            }\n            </>\n\n}","import _ from 'lodash';\nimport { insideNodeContainer } from '../graph/nodeContainer';\nimport { AudioOut } from '../nodes/audioOut';\nimport { Sampler } from '../nodes/sampler';\nimport { Sequencer } from '../nodes/sequencer';\nimport { UrBang } from '../nodes/urBang';\n\n\n\nlet nodeTypes = {\n    sequencer: Sequencer,\n    urbang: UrBang,\n    sampler: Sampler,\n    audioout: AudioOut,\n}\n\n// Put nodes inside container\nnodeTypes = _.mapValues(nodeTypes, node => insideNodeContainer(node));\n\nexport { nodeTypes };\n","import { Button } from \"antd\";\nimport { useState } from \"react\";\nimport { globalScheduler, s, useOnGlobalSchedulerStart, useOnGlobalSchedulerStop } from \"../scheduler/scheduler\";\n\n\nexport const UrBang = ({useTitle, useBangOutputHandle}) => {\n    useTitle(\"UrBang\");\n\n    // Use isRunning state following global scheduler state\n    const [isRunning, setRunning] = useState(false);\n    useOnGlobalSchedulerStart(() => setRunning(true));\n    useOnGlobalSchedulerStop(() => setRunning(false));\n    \n    // Setup urBang handle\n    const triggerUrBang = useBangOutputHandle(\"urbang-out\");\n    useOnGlobalSchedulerStart(() => globalScheduler.now().add(s(0.1)).schedule(triggerUrBang));\n\n    // Return start / stop button depending on global scheduler state\n    return isRunning ? \n            <Button onClick={() => globalScheduler.stop()}></Button> :\n            <Button onClick={() => globalScheduler.start()}></Button>;\n}\n","import { useEffect, useImperativeHandle, useRef, useState } from 'react'\nimport { Player } from 'tone';\nimport { Button, Checkbox, Col, Input, Row } from \"antd\";\nimport { s, useOnGlobalSchedulerStop } from '../scheduler/scheduler';\nimport { useNew } from '../common/hooks';\n\nexport const Sampler = ({useTitle, useAudioOutputHandle, useBangInputHandle, useData}) => {\n    useTitle(\"Sampler\");\n    const player = useNew(Player)();\n    // For debugging purposes, keep track of last playback time, throw silently if it's non-increasing\n    const lastPlaybackRef = useRef();\n    const startPlayer = time => {\n        const lastPb = lastPlaybackRef.current ?? s(-1);\n        if(lastPb.isOnOrAfter(time))\n            console.error(`Tried scheduling player playback in non-increasing fashion. Last playback: ${lastPb}, current playback: ${time}`)\n        else{\n            lastPlaybackRef.current = time;\n            player.start(time.toSeconds());\n        }           \n    }\n    useAudioOutputHandle(player.output, \"audio-out\");\n    useBangInputHandle(time =>startPlayer(time), \"player-start\");\n\n    const [loop, setLoop] = useData(false, \"loop\");\n    const [fpath, setFPath] = useData(\"808/Clap\", \"path\");\n\n    useEffect(() => player.set({loop}), [loop]);\n\n    const [playerReady, setPlayerReady] = useState(false);\n    useEffect(() => {\n        setPlayerReady(false);\n        const path = `sounds/drums/${fpath}.wav`; \n        player.load(path).then(() => setPlayerReady(true));\n    }, [fpath]);\n\n    useOnGlobalSchedulerStop(() => player.stop());\n    return <>\n    <Col style={{width: \"120px\"}}>\n        <Input onPressEnter={e => setFPath(e.target.value)} defaultValue={fpath} />\n    </Col>\n    <Checkbox onChange={(e) => setLoop(e.target.checked)} checked={loop}>Loop</Checkbox>\n    <Button onClick={() => player.start()} disabled={!playerReady}>Play</Button>\n    </>\n}","import { Button } from 'antd';\nimport { useState } from 'react';\nimport { useUpdateNodeInternals } from 'react-flow-renderer';\nimport * as Tone from 'tone';\n\nexport const AudioOut = ({useAudioInputHandle, useTitle}) => {\n    useTitle(\"Master\");\n    useAudioInputHandle(Tone.getDestination(), \"master-in\");\n    const [isOn, setOn] = useState(false);\n    return <Button onClick={() => {Tone.start(); setOn(true)}} type={isOn ? \"text\" : \"default\"}></Button>;\n}","import { Input } from 'antd';\nimport React, { useCallback, useContext, useState } from 'react';\nimport ReactFlow, { Background, Controls, MiniMap, ReactFlowProvider } from 'react-flow-renderer';\nimport { globalAudioGraph } from '../graph/audio';\nimport { globalBangGraph } from '../graph/bang';\nimport { FlowGraphContext } from '../graph/flow';\nimport { edgeTypes } from './edgeTypes';\nimport { nodeTypes } from './nodeTypes';\n\n\nconst AddNodePopup = ({x, y, dissapear, visible}) => {\n    const flowGraph = useContext(FlowGraphContext);\n    const popup = <div style={{\n        left: x + \"px\",\n        top: y + \"px\",\n        position: \"absolute\"\n        }}>\n            <Input placeholder=\"Add new element...\"\n                onPressEnter={event => {\n                    const type = event.target.value;\n                    flowGraph.createNode(type, {x, y});\n                    event.target.blur();\n                }}\n                autoFocus\n                onBlur={() => dissapear()} />\n        </div>\n    return visible ? popup : <></>;\n}\n\nexport const GraphView = ({props}) => {\n    const flowGraph = useContext(FlowGraphContext);\n    //const bangGraph = useContext(BangGraphContext); // TODO\n    //const audioGraph = useContext(AudioGraphContext); // TODO\n\n    const onConnectHandles = useCallback(({source, sourceHandle, target, targetHandle}) => {\n        if(globalAudioGraph.isAudioNode(sourceHandle) && globalAudioGraph.isAudioNode(targetHandle)){\n            flowGraph.createEdge(source, sourceHandle, target, targetHandle, \"audio\");\n        } else if (globalBangGraph.isBangNode(sourceHandle) && globalBangGraph.isBangNode(targetHandle)){\n            flowGraph.createEdge(source, sourceHandle, target, targetHandle, \"bang\");\n        } else {\n            console.log(\"Can't connect handles \", sourceHandle, \"and\", targetHandle, \"of different types\");\n        }\n\n    }, [flowGraph]);\n\n    const onElementsRemove = useCallback(elements => {\n        elements.map(element => flowGraph.deleteElement(element));\n    })\n\n    const onDragOver = useCallback(event => {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = \"move\"\n    }, []);\n\n    const onDrop = useCallback(event => {\n        event.preventDefault();\n        const {type, data} = JSON.parse(event.dataTransfer.getData(\"audio-tool/node-preset\"));\n        const position = flowGraph.reactFlowInstance.project({\n            x: event.clientX,\n            y: event.clientY\n        });\n\n        flowGraph.createNode(type, position, data);\n    }, [flowGraph])\n\n    const [{visible, x, y}, setPopupState] = useState({visible: false});\n    const onPaneContextMenu = useCallback(event => {\n        event.preventDefault();\n        event.stopPropagation();\n        setPopupState({visible: true, x: event.pageX-20, y: event.pageY-25});\n    }, [])\n\n    return <ReactFlowProvider>\n                <ReactFlow\n                    elements={flowGraph.elements}\n                    nodeTypes={nodeTypes}\n                    edgeTypes={edgeTypes}\n                    onLoad={flowGraph.setReactFlowInstance}\n                    onConnect={onConnectHandles}\n                    deleteKeyCode={\"Delete\"}\n                    onElementsRemove={onElementsRemove}\n                    onDragOver={onDragOver}\n                    onDrop={onDrop}\n                    onPaneContextMenu={onPaneContextMenu}\n                    >\n                    <Background variant=\"dots\" gap={24} size={0.5} />\n                    <MiniMap />\n                    <Controls />\n                </ReactFlow>\n                <AddNodePopup visible={visible} x={x} y={y} dissapear={() => setPopupState({visible: false})} />\n            </ReactFlowProvider>\n}","export const defaultFlowConfiguration = {\n  elements: [\n    {\n      id: \"urbang\",\n      type: \"urbang\",\n      position: {\n          x: 100,\n          y: 100\n      },\n    },{\n      id: \"audioout\",\n      type: \"audioout\",\n      position: {\n          x: 300,\n          y: 300\n      }\n    }\n    ],\n  position: [0, 0],\n  zoom: 1\n}","import { Button, Col, Input, Row } from 'antd';\nimport { useCallback, useContext, useEffect } from \"react\";\nimport { FlowGraphContext } from \"../graph/flow\";\nimport { defaultFlowConfiguration } from \"./defaultGraph\";\n\nconst storageKey = \"audio-tool\";\n\nexport const StorageController  = () => {\n    const flowGraph = useContext(FlowGraphContext);\n\n    const setGraphConfig = useCallback(flowConfig => {\n        flowGraph.setElements(flowConfig.elements);\n        const transform = {x: flowConfig.position[0], y: flowConfig.position[1]+100, zoom: flowConfig.zoom};\n        flowGraph.reactFlowInstance?.setTransform(transform);\n    }, [flowGraph]);\n\n    const getGraphConfig = useCallback(() =>\n        flowGraph.reactFlowInstance.toObject());\n\n    const saveGraph = useCallback(() => {\n        localStorage.setItem(storageKey, JSON.stringify(getGraphConfig()));\n    }, [flowGraph]);\n\n    const loadGraph = useCallback(() => {\n        const config = JSON.parse(localStorage.getItem(storageKey)) ?? defaultFlowConfiguration;\n        setGraphConfig(config);\n        console.log(\"Loaded config\", config);\n    }, [flowGraph]);\n\n    const resetGraph = useCallback(() => {\n        setGraphConfig(defaultFlowConfiguration);\n    }, [flowGraph]);\n\n    useEffect(() => flowGraph.reactFlowInstance && loadGraph(), [flowGraph.reactFlowInstance]);\n    return <Input.Group style={{padding: 5}}>\n        <Row gutter={5}>\n            <Col>\n                <Button onClick={() => saveGraph()}>Save</Button>\n            </Col>\n            <Col>\n                <Button onClick={() => loadGraph()}>Load</Button>\n            </Col>\n            <Col>\n                <Button onClick={() => resetGraph()}>Reset</Button>\n            </Col>\n        </Row>\n    </Input.Group>\n}","import { Col, Layout, Row } from 'antd';\nimport { Content, Header } from 'antd/lib/layout/layout';\nimport Sider from 'antd/lib/layout/Sider';\nimport Title from 'antd/lib/skeleton/Title';\nimport Footer from 'rc-table/lib/Footer';\nimport { PresetBrowser } from './views/presetBrowser';\n\nimport './App.css';\nimport 'antd/dist/antd.css';\nimport { GraphView } from './views/graphView';\nimport { StorageController } from './views/storageController';\nimport { FlowGraphProvider } from './graph/flow';\n\nfunction App() {\n  return <Row>\n    <Col span={18} style={{height: \"900px\"}}>\n      <FlowGraphProvider>\n        <StorageController />\n        <GraphView />\n      </FlowGraphProvider>\n    </Col>\n    <Col span={6}>\n      <PresetBrowser />\n    </Col>\n  </Row>\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}